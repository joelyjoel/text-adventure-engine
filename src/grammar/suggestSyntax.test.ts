import {suggestSyntax, wordnetParse} from './suggestSyntax';
import {PredicateSyntax} from '../PredicateSyntax';
import {allTenses} from '../util/tense';
import {deepCompare} from '../util/deepCompare'

describe.each([
  [
    {verb:'live', params: ['subject', 'in']},
    ['you', 'a house'],
  ],
  [
    {verb: 'chase', params: ['subject', 'object']},
    ['the cat', 'the dog']
  ],
  [
    {verb: 'seduce', params: ['subject', 'object', 'under']},
    ['the priest', 'the pope', 'a starry sky']
  ],
  [
    {verb: 'eat', params: ['subject', 'object']},
    ['the man', 'the bean'],
  ],
])('Testing suggestSyntax with strings generated by %j', ({verb, params}:any, args:string[]) => {
  const P = new PredicateSyntax(verb, params);
  const table = allTenses.map(tense => [tense, P.str(args, {tense})]);

  test.each(table)(`%s: Determining syntax of "%s"`, async (tense, str) => {
    let foundMatch = false;
    let numberOfTrees = 0;
    for await(let suggestion of suggestSyntax(str)) {
      numberOfTrees++;
      if(suggestion.verb == verb && deepCompare(suggestion.params, params))
        foundMatch = true;
    }
    expect(numberOfTrees).toBe(1);
    expect(foundMatch).toBe(true);

  });
});

test('Testing wordnetParse()', async () => {
  const forest = await wordnetParse('the man ate the bean');
  forest.assertNoDuplicateNonTerminalRules()
  forest.assertNoDuplicateRules();

  const [...trees] = forest.recursiveTrees();
  const strings = trees.map((tree:any) => forest.stringifyTree(tree));
  let counts:{[str:string]:number;} = {};
  for(let str of strings) {
    if(counts[str])
      counts[str]++;
    else 
      counts[str] = 1;
  }
  console.log(counts, `total: ${strings.length}`);
});

test.todo('suggestSyntax for strings in question form');
test.todo('suggestSyntax for strings in negated form');
test.todo('suggestSyntax for strings in noun-phrase form');
